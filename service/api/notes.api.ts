import {
  collection,
  getDocs,
  addDoc,
  updateDoc,
  doc,
  query,
  orderBy,
  limit,
  startAfter,
  getDoc,
  serverTimestamp,
  where,
  getCountFromServer,
  setDoc,
} from "firebase/firestore";
import { db } from "../config/firebase.config";

const updateTopicNotesPdfUrl = async (topicId: string, fileUrl: unknown) => {
  if (typeof topicId !== "string" || !topicId.trim()) {
    return;
  }

  if (typeof fileUrl !== "string" || !fileUrl.trim()) {
    return;
  }

  const topicRef = doc(db, "topics", topicId);
  await updateDoc(topicRef, {
    notes_pdf_url: fileUrl,
    updatedAt: serverTimestamp(),
  });
};

const updateTopicNotesCount = async (topicId: string, increment: number = 1) => {
  if (typeof topicId !== "string" || !topicId.trim() || topicId === "unknown_topic") {
    return;
  }

  try {
    const topicRef = doc(db, "topics", topicId);
    await updateDoc(topicRef, {
      total_notes: increment,
      updated_at: new Date().toISOString(),
    });
  } catch (error) {
    console.error("Error updating topic notes count:", error);
  }
};

export interface Note {
  id?: string;
  created_at: string;
  document_id: string;
  is_active: boolean;
  isDeleted: boolean;
  order: number;
  pdf_url: string;
  subject_id: string;
  title: string;
  topic_id: string;
  total_flashcards: number;
  updated_at: string;
}

// Add a new note
export const addNote = async (noteData: any) => {
  try {
    const nowIso = new Date().toISOString();
    const docRef = doc(collection(db, "notes"));

    const dataToSave = {
      subject_id: noteData.subject_id ?? "unknown_subject",
      topic_id: noteData.topic_id ?? "unknown_topic",
      title: noteData.title ?? "Untitled",
      pdf_url: noteData.pdf_url ?? null, // Firebase accepts null, but not undefined
      order: noteData.order || 1,
      is_active: true,
      isDeleted: false,
      total_flashcards: 0,
      created_at: nowIso,
      updated_at: nowIso,
      document_id: docRef.id,
    };

    console.log("Final data being sent to Firestore:", dataToSave);

    await setDoc(docRef, dataToSave);

    // Update topic's PDF URL and notes count
    await updateTopicNotesPdfUrl(noteData.topic_id, noteData.pdf_url);
    
    // Get current topic to increment total_notes
    if (noteData.topic_id && noteData.topic_id !== "unknown_topic") {
      try {
        const topicRef = doc(db, "topics", noteData.topic_id);
        const topicSnap = await getDoc(topicRef);
        
        if (topicSnap.exists()) {
          const topicData = topicSnap.data();
          const currentTotalNotes = topicData.total_notes || 0;
          await updateDoc(topicRef, {
            total_notes: currentTotalNotes + 1,
            updated_at: new Date().toISOString(),
          });
        }
      } catch (error) {
        console.error("Error updating topic notes count:", error);
      }
    }

    return {
      id: docRef.id,
      subject_id: noteData.subject_id,
      topic_id: noteData.topic_id,
      title: noteData.title,
      pdf_url: noteData.pdf_url,
      document_id: docRef.id,
      created_at: nowIso,
      updated_at: nowIso,
    };
  } catch (error) {
    console.error("Error adding note:", error);
    throw new Error("Failed to add note");
  }
};

// Update a note
export const updateNote = async (noteId: string, updateData: any) => {
  try {
    const noteRef = doc(db, "notes", noteId);

    console.log(updateData, "this is update data");
    await updateDoc(noteRef, {
      subject_id: updateData.subject_id,
      topic_id: updateData.topic_id,
      title: updateData.title,
      pdf_url: updateData.pdf_url,
      updated_at: new Date().toISOString(),
    });

    await updateTopicNotesPdfUrl(updateData.topic_id, updateData.pdf_url);
    return { id: noteId, ...updateData };
  } catch (error) {
    console.error("Error updating note:", error);
    throw new Error("Failed to update note");
  }
};

// Soft delete a note
export const deleteNote = async (noteId: string) => {
  try {
    const noteRef = doc(db, "notes", noteId);
    
    // Get note data before deletion to update topic count
    const noteSnap = await getDoc(noteRef);
    if (noteSnap.exists()) {
      const noteData = noteSnap.data();
      
      // Update topic's total_notes count
      if (noteData.topic_id && noteData.topic_id !== "unknown_topic") {
        try {
          const topicRef = doc(db, "topics", noteData.topic_id);
          const topicSnap = await getDoc(topicRef);
          
          if (topicSnap.exists()) {
            const topicData = topicSnap.data();
            const currentTotalNotes = topicData.total_notes || 0;
            const newTotalNotes = Math.max(0, currentTotalNotes - 1); // Prevent negative values
            
            await updateDoc(topicRef, {
              total_notes: newTotalNotes,
              updated_at: new Date().toISOString(),
            });
          }
        } catch (error) {
          console.error("Error updating topic notes count on deletion:", error);
        }
      }
    }
    
    // Soft delete the note using isDeleted field
    await updateDoc(noteRef, {
      isDeleted: true,
      updated_at: new Date().toISOString(),
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error deleting note:", error);
    throw new Error("Failed to delete note");
  }
};

// Get notes with pagination
export const getNotes = async (
  page: number = 1,
  pageSize: number = 10,
  lastVisible: any = null
) => {
  try {
    const notesRef = collection(db, "notes");
    let q = query(
      notesRef,
      where("isDeleted", "==", false),
      orderBy("created_at", "desc"),
      limit(pageSize)
    );

    if (lastVisible) {
      q = query(
        notesRef,
        where("isDeleted", "==", false),
        orderBy("created_at", "desc"),
        startAfter(lastVisible),
        limit(pageSize)
      );
    }

    const querySnapshot = await getDocs(q);
    const notes = querySnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    })) as Note[];

    const lastVisibleDoc = querySnapshot.docs[querySnapshot.docs.length - 1];
    const hasMore = querySnapshot.docs.length === pageSize;

    return {
      data: notes,
      lastVisible: lastVisibleDoc,
      hasMore,
      total: notes.length,
      page,
      pageSize,
    };
  } catch (error) {
    console.error("Error fetching notes:", error);
    throw new Error("Failed to fetch notes");
  }
};

// Get a single note by ID
export const getNoteById = async (noteId: string) => {
  try {
    const noteRef = doc(db, "notes", noteId);
    const noteSnap = await getDoc(noteRef);

    if (noteSnap.exists()) {
      return { id: noteSnap.id, ...noteSnap.data() } as Note;
    } else {
      throw new Error("Note not found");
    }
  } catch (error) {
    console.error("Error getting note:", error);
    throw new Error("Failed to get note");
  }
};

// Get notes by subject ID

export const getNotesBySubjectId = async (
  subjectId: string,
  page: number = 1,
  pageSize: number = 10,
  lastVisibleDocs: Record<number, any | null> = {},
  searchQuery: string = ""
) => {
  try {
    const notesRef = collection(db, "notes");

    if (searchQuery && searchQuery.trim() !== "") {
      const countQuery = query(
        notesRef,
        where("subject_id", "==", subjectId),
        where("isDeleted", "==", false),
        where("title", ">=", searchQuery),
        where("title", "<=", searchQuery + "\uf8ff")
      );
      const totalSnap = await getCountFromServer(countQuery);
      const total = totalSnap.data().count;

      let q;

      if (page === 1 || !lastVisibleDocs[page - 1]) {
        console.log("this is if");
        q = query(
          notesRef,
          where("subject_id", "==", subjectId),
          where("title", ">=", searchQuery),
          where("title", "<=", searchQuery + "\uf8ff"),
          where("isDeleted", "==", false),
          orderBy("created_at", "desc"),
          limit(pageSize)
        );
        console.log(q, "this is q");
      } else {
        console.log("this is else");
        q = query(
          notesRef,
          where("subject_id", "==", subjectId),
          where("title", ">=", searchQuery),
          where("title", "<=", searchQuery + "\uf8ff"),
          where("isDeleted", "==", false),
          orderBy("created_at", "desc"),
          startAfter(lastVisibleDocs[page - 1]),
          limit(pageSize)
        );
      }

      const querySnapshot = await getDocs(q);

      const notes = querySnapshot.docs.map((doc: any) => ({
        id: doc.id,
        ...doc.data(),
      })) as Note[];

      const lastVisibleDoc =
        querySnapshot.docs[querySnapshot.docs.length - 1] || null;

      console.log(notes, "this is notes");
      return {
        data: notes,
        lastVisible: lastVisibleDoc,
        total,
        page,
        pageSize,
      };
    }

    const countQuery = query(
      notesRef,
      where("subject_id", "==", subjectId),
      where("isDeleted", "==", false)
    );
    const totalSnap = await getCountFromServer(countQuery);
    const total = totalSnap.data().count;

    let q;
    if (page === 1 || !lastVisibleDocs[page - 1]) {
      q = query(
        notesRef,
        where("subject_id", "==", subjectId),
        where("isDeleted", "==", false),
        orderBy("created_at", "desc"),
        limit(pageSize)
      );
    } else {
      q = query(
        notesRef,
        where("subject_id", "==", subjectId),
        where("isDeleted", "==", false),
        orderBy("created_at", "desc"),
        startAfter(lastVisibleDocs[page - 1]),
        limit(pageSize)
      );
    }

    const querySnapshot = await getDocs(q);

    const notes = querySnapshot.docs.map((doc: any) => ({
      id: doc.id,
      ...doc.data(),
    })) as Note[];

    const lastVisibleDoc =
      querySnapshot.docs[querySnapshot.docs.length - 1] || null;

    return {
      data: notes,
      lastVisible: lastVisibleDoc,
      total,
      page,
      pageSize,
    };
  } catch (error) {
    console.error("Error fetching notes by subject:", error);
    throw new Error("Failed to fetch notes by subject");
  }
};

// Get notes by topic ID
export const getNotesByTopicId = async (
  topicId: string,
  page: number = 1,
  pageSize: number = 10,
  lastVisibleDocs: Record<number, any | null> = {},
  searchQuery: string = ""
) => {
  try {
    const notesRef = collection(db, "notes");

    console.log(searchQuery, "this is search query");
    if (searchQuery && searchQuery.trim() !== "") {
      const countQuery = query(
        notesRef,
        where("topic_id", "==", topicId),
        where("isDeleted", "==", false),
        where("title", ">=", searchQuery),
        where("title", "<=", searchQuery + "\uf8ff")
      );
      const totalSnap = await getCountFromServer(countQuery);
      const total = totalSnap.data().count;

      let q;

      if (page === 1 || !lastVisibleDocs[page - 1]) {
        q = query(
          notesRef,
          where("topic_id", "==", topicId),
          where("title", ">=", searchQuery),
          where("title", "<=", searchQuery + "\uf8ff"),
          where("isDeleted", "==", false),
          orderBy("created_at", "desc"),
          limit(pageSize)
        );
      } else {
        q = query(
          notesRef,
          where("topic_id", "==", topicId),
          where("title", ">=", searchQuery),
          where("title", "<=", searchQuery + "\uf8ff"),
          where("isDeleted", "==", false),
          orderBy("created_at", "desc"),
          startAfter(lastVisibleDocs[page - 1]),
          limit(pageSize)
        );
      }

      const querySnapshot = await getDocs(q);

      const notes = querySnapshot.docs.map((doc: any) => ({
        id: doc.id,
        ...doc.data(),
      })) as Note[];

      const lastVisibleDoc =
        querySnapshot.docs[querySnapshot.docs.length - 1] || null;

      return {
        data: notes,
        lastVisible: lastVisibleDoc,
        total,
        page,
        pageSize,
      };
    }

    const countQuery = query(
      notesRef,
      where("topic_id", "==", topicId),
      where("isDeleted", "==", false)
    );

    const totalSnap = await getCountFromServer(countQuery);
    const total = totalSnap.data().count;

    let q;
    if (page === 1 || !lastVisibleDocs[page - 1]) {
      q = query(
        notesRef,
        where("topic_id", "==", topicId),
        where("isDeleted", "==", false),
        orderBy("created_at", "desc"),
        limit(pageSize)
      );
    } else {
      q = query(
        notesRef,
        where("topic_id", "==", topicId),
        where("isDeleted", "==", false),
        orderBy("created_at", "desc"),
        startAfter(lastVisibleDocs[page - 1]),
        limit(pageSize)
      );
    }

    const querySnapshot = await getDocs(q);

    const notes = querySnapshot.docs.map((doc: any) => ({
      id: doc.id,
      ...doc.data(),
    })) as Note[];

    const lastVisibleDoc =
      querySnapshot.docs[querySnapshot.docs.length - 1] || null;

    return {
      data: notes,
      lastVisible: lastVisibleDoc,
      total,
      page,
      pageSize,
    };
  } catch (error) {
    console.error("Error fetching notes by topic:", error);
    throw new Error("Failed to fetch notes by topic");
  }
};
